1. DescripciÃ³n detallada de la aplicaciÃ³n

La aplicaciÃ³n digitaliza y automatiza un proceso que actualmente se realiza de forma manual entre vendedores, el administrador en Colombia (tu papÃ¡) y un administrador en Venezuela.

ðŸ‘¥ Roles principales

Administrador Colombia

Revisa los giros enviados por vendedores y usuarios.

EnvÃ­a los giros aprobados a Venezuela.

Recibe resultados desde Venezuela (completado, error, comprobante).

Devuelve el estado final a vendedores o clientes.

Administrador Venezuela

Actualiza la tasa de cambio (varias veces al dÃ­a).

Procesa los giros enviados desde Colombia.

Devuelve estado + comprobante o error.

Vendedores (puntos fÃ­sicos)

Atienden clientes presenciales.

Registran clientes y destinatarios frecuentes.

Crean giros.

Reciben resultados del administrador.

Usuarios finales de la app (no presenciales)

Crean cuenta.

Guardan sus datos y sus destinatarios.

Registran giros subiendo comprobante del pago.

Reciben notificaciones del estado del giro.


2. Flujo general del sistema

El administrador Venezuela actualiza la tasa de cambio, que queda vigente en toda la app.

Un vendedor o usuario crea un giro, indicando:

Cliente remitente

Destinatario

Monto en COP o en Bs

Sistema calcula automÃ¡ticamente el valor correspondiente segÃºn la tasa.

El giro llega al administrador Colombia, quien:

Revisa datos

Revisa comprobante (si es usuario de la app)

Aprueba / rechaza

Si aprueba:

EnvÃ­a el giro a Venezuela

El administrador Venezuela:

Realiza transferencia bancaria al destinatario

Devuelve estado + comprobante

El administrador Colombia reenvÃ­a el estado final al vendedor o usuario.

. Modelo de datos â€“ PostgreSQL (TypeORM)

A continuaciÃ³n las entidades diseÃ±adas para usarse con TypeORM en NestJS.

ðŸ“Œ Usuario

Representa tanto a vendedores como a usuarios normales y administradores.

@Entity('users')
export class User {
  @PrimaryGeneratedColumn()
  id: number;

  @Column()
  name: string;

  @Column({ unique: true })
  phone: string;

  @Column({ unique: true })
  email: string;

  @Column()
  password: string;

  @Column({
    type: 'enum',
    enum: ['admin_colombia', 'admin_venezuela', 'vendedor', 'cliente'],
  })
  role: string;

  @Column({ nullable: true })
  pointId: number; // solo si es vendedor

  @ManyToOne(() => Point, point => point.vendedores)
  point: Point;
}

ðŸ“Œ Punto fÃ­sico (Point)

UbicaciÃ³n donde trabajan los vendedores.

@Entity('points')
export class Point {
  @PrimaryGeneratedColumn()
  id: number;

  @Column()
  name: string;

  @Column()
  address: string;

  @OneToMany(() => User, user => user.point)
  vendedores: User[];
}

ðŸ“Œ Cliente

Clientes que van presencialmente a los puntos fÃ­sicos.

@Entity('clients')
export class Client {
  @PrimaryGeneratedColumn()
  id: number;

  @Column()
  name: string;

  @Column()
  phone: string;

  @ManyToOne(() => User)
  vendedor: User; // quiÃ©n atendiÃ³ y registrÃ³ al cliente
}

ðŸ“Œ Destinatario

A quiÃ©n llega el dinero en Venezuela.

@Entity('destinatarios')
export class Destinatario {
  @PrimaryGeneratedColumn()
  id: number;

  @Column()
  fullName: string;

  @Column()
  documentId: string;

  @Column()
  bankName: string;

  @Column()
  accountNumber: string;

  @Column()
  accountType: string;

  @ManyToOne(() => Client)
  clientColombia: Client;

  @ManyToOne(() => User)
  userApp: User; // para usuarios que usan la app directamente
}

ðŸ“Œ Tasa de cambio (ExchangeRate)
@Entity('exchange_rates')
export class ExchangeRate {
  @PrimaryGeneratedColumn()
  id: number;

  @Column('numeric', { precision: 10, scale: 2 })
  rate: number;

  @Column({ type: 'timestamp' })
  createdAt: Date;
}

ðŸ“Œ Giro

El objeto principal del sistema.

@Entity('giros')
export class Giro {
  @PrimaryGeneratedColumn()
  id: number;

  @ManyToOne(() => User)
  createdBy: User; // vendedor o usuario app

  @ManyToOne(() => Client, { nullable: true })
  clientPresencial: Client;

  @ManyToOne(() => User, { nullable: true })
  clientApp: User;

  @ManyToOne(() => Destinatario)
  destinatario: Destinatario;

  @Column('numeric', { precision: 12, scale: 2 })
  amountCOP: number;

  @Column('numeric', { precision: 12, scale: 2 })
  amountBs: number;

  @Column('numeric', { precision: 10, scale: 2 })
  rateUsed: number;

  @Column({
    type: 'enum',
    enum: ['pendiente', 'enviado_venezuela', 'procesando', 'completado', 'rechazado'],
    default: 'pendiente',
  })
  status: string;

  @Column({ nullable: true })
  comprobanteCliente: string; // URL

  @Column({ nullable: true })
  comprobanteVenezuela: string; // URL

  @Column({ type: 'timestamp', default: () => 'NOW()' })
  createdAt: Date;
}

ðŸ“Œ Historial de estados del giro
@Entity('giro_status_history')
export class GiroStatusHistory {
  @PrimaryGeneratedColumn()
  id: number;

  @ManyToOne(() => Giro)
  giro: Giro;

  @Column()
  status: string;

  @Column('text', { nullable: true })
  note: string;

  @Column({ type: 'timestamp', default: () => 'NOW()' })
  changedAt: Date;
}

ðŸ§© 4. TecnologÃ­as a usar
Backend â€“ NestJS + TypeScript

NestJS

TypeORM

PostgreSQL

JWT para autenticaciÃ³n

Multer o S3 para comprobantes (segÃºn hosting)

Zod o class-validator para validaciones

Frontend â€“ Next.js 14 (App Router)

Next.js + React

TailwindCSS

Axios / React Query

DiseÃ±o responsive (principal foco: mÃ³viles)

Server Actions cuando aplique

1. CÃ¡lculo de montos (COP â†”ï¸Ž Bs) â€” reglas y ejemplo
Principio

La aplicaciÃ³n congela la tasa usada en el momento de crear el giro. Es decir, al crear una Giro se guarda la rateUsed (la tasa actual) para que los valores sean reproducibles aunque luego cambie la tasa global.

rate se entiende como: 1 VES = rate COP
(ej. rate = 213 significa 1 bolÃ­var â‰ˆ 213 pesos)

FÃ³rmulas

Si el usuario ingresa COP y queremos saber Bs:

amountBs = amountCop / rate


Si el usuario ingresa Bs y queremos saber COP:

amountCop = amountBs * rate

Ejemplo numÃ©rico

rate = 213

Si dan 160000 COP â†’ 160000 / 213 = 751.17 Bs

Si quieren que lleguen 751.17 Bs â†’ 751.17 * 213 = 160000 COP

Reglas de negocio adicionales (sugeridas)

Redondeo: almacenar amountBs con 4 decimales y amountCop con 2 decimales.

Mostrar al cliente un resumen con rateUsed, amountCOP, amountBs y timestamp.

Siempre grabar en la transacciÃ³n: rateUsed, amountCOP, amountBs, rateId (si usas rates histÃ³ricos).

3. Estructura del Backend (NestJS + TypeORM + TypeScript)

Objetivo: modular, testeable y con capas claras.

/backend
â”œâ”€ src
â”‚  â”œâ”€ main.ts
â”‚  â”œâ”€ app.module.ts
â”‚  â”œâ”€ config/
â”‚  â”‚   â”œâ”€ database.config.ts
â”‚  â”‚   â””â”€ aws.config.ts
â”‚  â”œâ”€ common/
â”‚  â”‚   â”œâ”€ dto/
â”‚  â”‚   â”œâ”€ filters/
â”‚  â”‚   â”œâ”€ interceptors/
â”‚  â”‚   â””â”€ guards/
â”‚  â”œâ”€ modules/
â”‚  â”‚   â”œâ”€ auth/
â”‚  â”‚   â”‚   â”œâ”€ auth.module.ts
â”‚  â”‚   â”‚   â”œâ”€ auth.controller.ts
â”‚  â”‚   â”‚   â”œâ”€ auth.service.ts
â”‚  â”‚   â”‚   â””â”€ jwt.strategy.ts
â”‚  â”‚   â”œâ”€ users/
â”‚  â”‚   â”‚   â”œâ”€ users.module.ts
â”‚  â”‚   â”‚   â”œâ”€ users.controller.ts
â”‚  â”‚   â”‚   â”œâ”€ users.service.ts
â”‚  â”‚   â”‚   â””â”€ entities/user.entity.ts
â”‚  â”‚   â”œâ”€ points/
â”‚  â”‚   â”œâ”€ vendors/
â”‚  â”‚   â”œâ”€ clients/
â”‚  â”‚   â”œâ”€ beneficiaries/
â”‚  â”‚   â”œâ”€ transactions/
â”‚  â”‚   â”‚   â”œâ”€ transactions.module.ts
â”‚  â”‚   â”‚   â”œâ”€ transactions.controller.ts
â”‚  â”‚   â”‚   â”œâ”€ transactions.service.ts
â”‚  â”‚   â”‚   â”œâ”€ dto/
â”‚  â”‚   â”‚   â””â”€ entities/giro.entity.ts
â”‚  â”‚   â”œâ”€ rates/
â”‚  â”‚   â”œâ”€ proofs/          -- subida y metadatos de comprobantes
â”‚  â”‚   â””â”€ notifications/   -- encolado y log (sin integrar WA por ahora)
â”‚  â”œâ”€ shared/
â”‚  â”‚   â”œâ”€ typeorm/         -- migraciones, factories, seeding
â”‚  â”‚   â””â”€ services/        -- s3Service, fileService
â”‚  â””â”€ jobs/
â”‚      â”œâ”€ queue.processor.ts -- workers para tareas largas
â”‚      â””â”€ cron.tasks.ts      -- jobs periÃ³dicos si aplica
â”œâ”€ ormconfig.ts
â”œâ”€ tsconfig.json
â””â”€ package.json
Principios y responsabilidades

Controllers: recibir solicitudes HTTP, validaciones iniciales con DTOs (class-validator).

Services: lÃ³gica de negocio (crear transacciÃ³n, validar comprobante, cÃ¡lculo, llamadas a storage).

Repositories / TypeORM Entities: acceso a DB, consultas complejas dentro de repositorios.

Guards: autorizaciÃ³n por roles (vendedor vs admin).

Interceptors / Filters: logging, manejo de errores, transformaciÃ³n de respuestas.

Jobs / Queue: para procesamiento pesado (p.ej. OCR de comprobantes, envÃ­o masivo de notificaciones); usar Bull o RabbitMQ si escalas.

Config: centralizar variables (DB, S3, JWT) con @nestjs/config.
Infraestructura

4. Estructura del Frontend (Next.js â€” responsive, mÃ³vil-first)

Usaremos Next.js (App Router) + TypeScript + TailwindCSS. Separar responsabilidades y favorecer componentes reutilizables.

/frontend
â”œâ”€ app/                         -- App Router
â”‚  â”œâ”€ layout.tsx
â”‚  â”œâ”€ page.tsx                  -- homepage / login
â”‚  â”œâ”€ dashboard/
â”‚  â”‚   â”œâ”€ layout.tsx
â”‚  â”‚   â”œâ”€ page.tsx
â”‚  â”‚   â”œâ”€ vendors/
â”‚  â”‚   â””â”€ transactions/
â”‚  â””â”€ api/                      -- server actions si aplica (para SSR)
â”œâ”€ components/
â”‚  â”œâ”€ forms/
â”‚  â”œâ”€ ui/                       -- Button, Input, Card
â”‚  â””â”€ transaction/              -- TransactionForm, TransactionCard
â”œâ”€ hooks/
â”‚  â”œâ”€ useAuth.ts
â”‚  â””â”€ useTransactions.ts
â”œâ”€ services/
â”‚  â”œâ”€ api.ts                    -- axios instance
â”‚  â””â”€ transactions.api.ts       -- llamadas a endpoints
â”œâ”€ stores/                      -- Zustand / RTK slices (ver recomendaciÃ³n abajo)
â”‚  â””â”€ uiStore.ts
â”œâ”€ styles/
â”‚  â””â”€ globals.css               -- Tailwind
â”œâ”€ types/
â”‚  â””â”€ dto.ts
â””â”€ package.json

UX y diseÃ±o

MÃ³vil-first: usar breakpoints y componentes adaptativos.

Forms: validaciÃ³n cliente con Zod o React Hook Form + Zod.

Fetch de datos: TanStack Query (React Query) para cache, revalidaciÃ³n y estados (loading, error).

Upload de comprobantes: componente para previsualizar y subir (presigned URLs si S3).

AutenticaciÃ³n: mantener token JWT en HttpOnly cookie o secure storage (mÃ³vil).

BÃºsquedas rÃ¡pidas: bÃºsqueda por nombre/telefono en clientes frecuentes y destinatarios con autocompletar.

PostgreSQL (Railway / Supabase / Render)

Deploy del backend en Railway o Render

Deploy del frontend en Vercel